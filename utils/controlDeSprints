# Dudas:
- Como estructurar el proyecto (init, clases)
- Como importar variables (config)
- Como hacer la lógica del juego (fábrica y update) --> Pantalla_inicio y Escenario
- Como poner los comentarios

# Fernando (20/11):
- Pantalla_inicio   --> Clase para el "home"
- Escenario/Fábrica --> Clase para el "juego"
- escenario.codigoPausa == "SALIDA_CAMION"
- escenario.mario.pintar(self.X_MARIO, self.MARGEN_ALTO, self.ALTURA_PISO, self.codigo_pausa == "ERROR MARIO")
- Los parpadeos van "despacio" por el fps


# -- TO DO --
 * Añadir Jefe?, herencia de Personajes, imágenes!!!
 * Añadir esquema de clases en la memoria del proyecto
 * Añadir pantalla de inicio y selector de dificultad
 * Comproabr que estén todos los properties/setters

# Sprint 1.A: Objetos e interfaz gráfica (13/11)
 - Crear una clase para cada elemento principal del juego: Personajes, Camión,
Paquetes, Fabrica
 - Parte de la lógica de comportamiento de cada entidad debe estar contenida en su clase
correspondiente

# Sprint 1.B: Objetos e interfaz gráfica (/11)
 - Mover clases a su archivo/módulo correspondiente. (Añadir imports)
 - Practicar la lógica de Pyxel (como dibujar y update/draw)
 - Crear el esqueleto de toda la lógica del juego

 - En main se define el entorno de pyxel y se ejecuta una vez
   El resto del código en update()

 - Diseñar la interfaz gráfica del escenario: una única pantalla con las cintas, los pisos,
las escaleras y el camión. (SIN MOVIMIENTO DE LOS PERSONAJES)
 - Implementar un marcador de puntuación y contador de errores (fallos) visible
durante la partida.
 - Definir las estructuras de datos básicas que gestionarán el estado de las cintas, los
paquetes en tránsito y el nivel de dificultad.

# Sprint 2: Movimiento de Mario y Luigi

# Sprint 3: Movimiento de los paquetes en las cintas

# Sprint 4: Sistema de puntuación, fallos y final de partida

# Sprint 5: Niveles de dificultad y ajustes finales (opcional)